--- a/chrome/browser/extensions/api/module/module.cc
+++ b/chrome/browser/extensions/api/module/module.cc
@@ -13,6 +13,9 @@
 #include "chrome/common/extensions/manifest_url_handler.h"
 #include "extensions/browser/extension_prefs.h"
 #include "extensions/browser/extension_system.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/common/chrome_switches.h"
 
 namespace extensions {
 
@@ -24,6 +27,8 @@ namespace {
 // the ExtensionUpdater will append a ap= parameter to the URL when checking if
 // a new version of the extension is available.
 const char kUpdateURLData[] = "update_url_data";
+const char kNoCurrentWindowError[] = "No current window";
+const char kCouldNotIdentifyTab[] = "Could not find tab with specified ID";
 
 }  // namespace
 
@@ -63,4 +68,36 @@ bool ExtensionIsAllowedFileSchemeAccessF
   return true;
 }
 
+bool ExtensionIsChromelessWindowFunction::RunImpl() {
+  bool is_chromeless = false;
+
+  int tab_id = -1;
+  if (!args_->GetInteger(0, &tab_id)) {
+    Browser* browser = GetCurrentBrowser();
+    if (!browser) {
+      error_ = extension::kNoCurrentWindowError;
+      return false;
+    }
+    is_chromeless = browser->is_chromeless_mode();
+  }
+  else {
+    Browser* browser = NULL;
+    if (!ExtensionTabUtil::GetTabById(tab_id,
+                                      GetProfile(),
+                                      NULL,
+                                      &browser,
+                                      NULL,
+                                      NULL,
+                                      NULL)) {
+      error_ = extension::kCouldNotIdentifyTab;
+      return false;
+    }
+    is_chromeless = browser->is_chromeless_mode();
+  }
+
+  SetResult(new base::FundamentalValue(is_chromeless));
+
+  return true;
+}
+
 }  // namespace extensions
--- a/chrome/browser/extensions/api/module/module.h
+++ b/chrome/browser/extensions/api/module/module.h
@@ -54,6 +54,18 @@ class ExtensionIsAllowedFileSchemeAccess
   virtual bool RunImpl() OVERRIDE;
 };
 
+class ExtensionIsChromelessWindowFunction : public ChromeSyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("extension.isChromelessWindow",
+                             EXTENSION_IS_CHROMELESS_WINDOW);
+
+ protected:
+  virtual ~ExtensionIsChromelessWindowFunction() {}
+
+  // ExtensionFunction:
+  virtual bool RunImpl() OVERRIDE;
+};
+
 }  // namespace extensions
 
 #endif  // CHROME_BROWSER_EXTENSIONS_API_MODULE_MODULE_H_
--- a/chrome/browser/sessions/session_service.cc
+++ b/chrome/browser/sessions/session_service.cc
@@ -1552,7 +1552,8 @@ bool SessionService::ShouldTrackChangesT
 bool SessionService::ShouldTrackBrowser(Browser* browser) const {
   AppType app_type = browser->is_app() ? TYPE_APP : TYPE_NORMAL;
   return browser->profile() == profile() &&
-         should_track_changes_for_browser_type(browser->type(), app_type);
+         should_track_changes_for_browser_type(browser->type(), app_type) &&
+         !browser->is_chromeless_mode();
 }
 
 bool SessionService::should_track_changes_for_browser_type(Browser::Type type,
--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -252,6 +252,7 @@ Browser::CreateParams::CreateParams(Prof
     : type(TYPE_TABBED),
       profile(profile),
       host_desktop_type(host_desktop_type),
+      is_chromeless_mode(false),
       app_type(APP_TYPE_HOST),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
@@ -264,6 +265,7 @@ Browser::CreateParams::CreateParams(Type
     : type(type),
       profile(profile),
       host_desktop_type(host_desktop_type),
+      is_chromeless_mode(false),
       app_type(APP_TYPE_HOST),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
@@ -271,6 +273,16 @@ Browser::CreateParams::CreateParams(Type
 }
 
 // static
+Browser::CreateParams Browser::CreateParams::CreateChromeless(
+    Profile * profile,
+    chrome::HostDesktopType host_desktop_type)
+{
+  CreateParams params(profile, host_desktop_type);
+  params.is_chromeless_mode = true;
+  return params;
+}
+
+// static
 Browser::CreateParams Browser::CreateParams::CreateForApp(
     Type type,
     const std::string& app_name,
@@ -334,6 +346,7 @@ Browser::Browser(const CreateParams& par
       tab_strip_model_(new TabStripModel(tab_strip_model_delegate_.get(),
                                          params.profile)),
       app_name_(params.app_name),
+      is_chromeless_mode_(params.is_chromeless_mode),
       app_type_(params.app_type),
       cancel_download_confirmation_state_(NOT_PROMPTED),
       override_bounds_(params.initial_bounds),
@@ -532,6 +545,10 @@ bool Browser::HasFindBarController() con
   return find_bar_controller_.get() != NULL;
 }
 
+bool Browser::is_chromeless_mode () const {
+  return is_chromeless_mode_;
+}
+
 bool Browser::is_app() const {
   return !app_name_.empty();
 }
@@ -577,7 +594,7 @@ base::string16 Browser::GetWindowTitleFo
     return title;
 #endif
   // Don't append the app name to window titles on app frames and app popups
-  return is_app() ?
+  return (is_app() || is_chromeless_mode()) ?
       title :
       l10n_util::GetStringFUTF16(IDS_BROWSER_WINDOW_TITLE_FORMAT, title);
 }
@@ -663,7 +680,8 @@ void Browser::OnWindowClosing() {
     tab_restore_service->BrowserClosing(tab_restore_service_delegate());
 #endif
 
-  if (tab_restore_service && is_type_tabbed() && tab_strip_model_->count())
+  if (tab_restore_service && is_type_tabbed() &&
+          tab_strip_model_->count() && !is_chromeless_mode())
     tab_restore_service->BrowserClosing(tab_restore_service_delegate());
 
   // TODO(sky): convert session/tab restore to use notification.
@@ -2202,6 +2220,7 @@ bool Browser::ShouldShowLocationBar() co
       app_name() == DevToolsWindow::kDevToolsApp ||
       !CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableStreamlinedHostedApps))
+   if (!is_chromeless_mode())
     return false;
 
   // If kEnableStreamlinedHostedApps is true, show the locaiton bar for non
@@ -2222,16 +2241,19 @@ bool Browser::SupportsWindowFeatureImpl(
   unsigned int features = FEATURE_INFOBAR | FEATURE_DOWNLOADSHELF;
 
   if (is_type_tabbed())
+   if (!is_chromeless_mode())
     features |= FEATURE_BOOKMARKBAR;
 
   if (!hide_ui_for_fullscreen) {
     if (!is_type_tabbed())
+     if (!is_chromeless_mode())
       features |= FEATURE_TITLEBAR;
 
     if (is_type_tabbed())
       features |= FEATURE_TABSTRIP;
 
     if (is_type_tabbed())
+     if (!is_chromeless_mode())
       features |= FEATURE_TOOLBAR;
 
     if (ShouldShowLocationBar())
--- a/chrome/browser/ui/browser.h
+++ b/chrome/browser/ui/browser.h
@@ -162,6 +162,11 @@ class Browser : public TabStripModelObse
                                      Profile* profile,
                                      chrome::HostDesktopType host_desktop_type);
 
+    // Like Create, but creates a chromeless browser.
+    static CreateParams CreateChromeless(
+        Profile * profile,
+        chrome::HostDesktopType host_desktop_type);
+
     static CreateParams CreateForDevTools(
         Profile* profile,
         chrome::HostDesktopType host_desktop_type);
@@ -184,6 +189,9 @@ class Browser : public TabStripModelObse
     // Type of app (host or child). See description of AppType.
     AppType app_type;
 
+    // If the browser instance is supposed to be a chromeless one.
+    bool is_chromeless_mode;
+
     // The bounds of the window to open.
     gfx::Rect initial_bounds;
 
@@ -458,6 +466,7 @@ class Browser : public TabStripModelObse
   bool is_type_tabbed() const { return type_ == TYPE_TABBED; }
   bool is_type_popup() const { return type_ == TYPE_POPUP; }
 
+  bool is_chromeless_mode() const;
   bool is_app() const;
   bool is_devtools() const;
 
@@ -822,6 +831,8 @@ class Browser : public TabStripModelObse
   // 2) we launch an undocked devtool window.
   std::string app_name_;
 
+  bool is_chromeless_mode_;
+
   // Type of app (host or child). See description of AppType.
   AppType app_type_;
 
--- a/chrome/browser/ui/browser_command_controller.cc
+++ b/chrome/browser/ui/browser_command_controller.cc
@@ -876,7 +876,8 @@ class BrowserCommandController::Intersti
 
 bool BrowserCommandController::IsShowingMainUI() {
   bool should_hide_ui = window() && window()->ShouldHideUIForFullscreen();
-  return browser_->is_type_tabbed() && !should_hide_ui;
+  return browser_->is_type_tabbed() && !should_hide_ui &&
+      !browser_->is_chromeless_mode();
 }
 
 void BrowserCommandController::InitCommandState() {
@@ -891,9 +892,11 @@ void BrowserCommandController::InitComma
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_CLOSE_WINDOW, true);
-  command_updater_.UpdateCommandEnabled(IDC_NEW_TAB, true);
+  command_updater_.UpdateCommandEnabled(IDC_NEW_TAB,
+                                        !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_CLOSE_TAB, true);
-  command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB, true);
+  command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB,
+                                        !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_RESTORE_TAB, false);
 #if defined(OS_WIN) && defined(USE_ASH)
   if (browser_->host_desktop_type() != chrome::HOST_DESKTOP_TYPE_ASH)
@@ -967,20 +970,23 @@ void BrowserCommandController::InitComma
   command_updater_.UpdateCommandEnabled(IDC_ZOOM_MINUS, true);
 
   // Show various bits of UI
-  UpdateOpenFileState(&command_updater_);
+  UpdateOpenFileState(&command_updater_, browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_CREATE_SHORTCUTS, false);
   UpdateCommandsForDevTools();
   command_updater_.UpdateCommandEnabled(IDC_TASK_MANAGER, CanOpenTaskManager());
   command_updater_.UpdateCommandEnabled(IDC_SHOW_HISTORY,
-                                        !profile()->IsGuestSession());
+                                        !profile()->IsGuestSession() &&
+                                            !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_SHOW_DOWNLOADS, true);
   command_updater_.UpdateCommandEnabled(IDC_HELP_PAGE_VIA_KEYBOARD, true);
   command_updater_.UpdateCommandEnabled(IDC_HELP_PAGE_VIA_MENU, true);
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARKS_MENU,
-                                        !profile()->IsGuestSession());
+                                        !profile()->IsGuestSession() &&
+                                            !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_RECENT_TABS_MENU,
                                         !profile()->IsGuestSession() &&
-                                        !profile()->IsOffTheRecord());
+                                        !profile()->IsOffTheRecord() &&
+                                        !browser_->is_chromeless_mode());
 #if defined(OS_CHROMEOS)
   command_updater_.UpdateCommandEnabled(IDC_TAKE_SCREENSHOT, true);
 #endif
@@ -993,9 +999,10 @@ void BrowserCommandController::InitComma
   // Navigation commands
   command_updater_.UpdateCommandEnabled(
       IDC_HOME,
-      normal_window || (CommandLine::ForCurrentProcess()->HasSwitch(
+      (normal_window || (CommandLine::ForCurrentProcess()->HasSwitch(
                             switches::kEnableStreamlinedHostedApps) &&
-                        browser_->is_app()));
+                        browser_->is_app())) &&
+               !browser_->is_chromeless_mode());
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_SELECT_NEXT_TAB, normal_window);
@@ -1028,7 +1035,9 @@ void BrowserCommandController::InitComma
 #endif
 
   // Show various bits of UI
-  command_updater_.UpdateCommandEnabled(IDC_CLEAR_BROWSING_DATA, normal_window);
+  command_updater_.UpdateCommandEnabled(IDC_CLEAR_BROWSING_DATA,
+                                        normal_window &&
+                                            !browser_->is_chromeless_mode());
 
   // The upgrade entry and the view incompatibility entry should always be
   // enabled. Whether they are visible is a separate matter determined on menu
@@ -1052,15 +1061,18 @@ void BrowserCommandController::InitComma
 // static
 void BrowserCommandController::UpdateSharedCommandsForIncognitoAvailability(
     CommandUpdater* command_updater,
-    Profile* profile) {
+    Profile* profile,
+    bool started_in_chromeless) {
   IncognitoModePrefs::Availability incognito_availability =
       IncognitoModePrefs::GetAvailability(profile->GetPrefs());
   command_updater->UpdateCommandEnabled(
       IDC_NEW_WINDOW,
-      incognito_availability != IncognitoModePrefs::FORCED);
+      incognito_availability != IncognitoModePrefs::FORCED &&
+      !started_in_chromeless);
   command_updater->UpdateCommandEnabled(
       IDC_NEW_INCOGNITO_WINDOW,
-      incognito_availability != IncognitoModePrefs::DISABLED);
+      incognito_availability != IncognitoModePrefs::DISABLED &&
+      !started_in_chromeless);
 
   // Bookmark manager and settings page/subpages are forced to open in normal
   // mode. For this reason we disable these commands when incognito is forced.
@@ -1068,7 +1080,8 @@ void BrowserCommandController::UpdateSha
       incognito_availability != IncognitoModePrefs::FORCED;
   command_updater->UpdateCommandEnabled(
       IDC_SHOW_BOOKMARK_MANAGER,
-      browser_defaults::bookmarks_enabled && command_enabled);
+      browser_defaults::bookmarks_enabled && command_enabled &&
+      !started_in_chromeless);
   ExtensionService* extension_service = profile->GetExtensionService();
   bool enable_extensions =
       extension_service && extension_service->extensions_enabled();
@@ -1081,7 +1094,10 @@ void BrowserCommandController::UpdateSha
 }
 
 void BrowserCommandController::UpdateCommandsForIncognitoAvailability() {
-  UpdateSharedCommandsForIncognitoAvailability(&command_updater_, profile());
+  UpdateSharedCommandsForIncognitoAvailability(
+      &command_updater_,
+      profile(),
+      browser_->is_chromeless_mode());
 
   if (!IsShowingMainUI()) {
     command_updater_.UpdateCommandEnabled(IDC_IMPORT_SETTINGS, false);
@@ -1106,17 +1122,20 @@ void BrowserCommandController::UpdateCom
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB,
-      !browser_->is_app() && CanDuplicateTab(browser_));
+      !browser_->is_chromeless_mode() && !browser_->is_app()
+          && CanDuplicateTab(browser_));
 
   // Page-related commands
   window()->SetStarredState(
       BookmarkTabHelper::FromWebContents(current_web_contents)->is_starred());
   window()->ZoomChangedForActiveTab(false);
   command_updater_.UpdateCommandEnabled(IDC_VIEW_SOURCE,
-                                        CanViewSource(browser_));
+                                        CanViewSource(browser_)
+                                            && !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_EMAIL_PAGE_LOCATION,
-                                        CanEmailPageLocation(browser_));
-  if (browser_->is_devtools())
+                                        CanEmailPageLocation(browser_)
+                                            && !browser_->is_chromeless_mode());
+  if (browser_->is_devtools() && browser_->is_chromeless_mode())
     command_updater_.UpdateCommandEnabled(IDC_OPEN_FILE, false);
 
   // Changing the encoding is not possible on Chrome-internal webpages.
@@ -1132,10 +1151,12 @@ void BrowserCommandController::UpdateCom
 #if !defined(OS_MACOSX)
   command_updater_.UpdateCommandEnabled(
       IDC_CREATE_SHORTCUTS,
-      CanCreateApplicationShortcuts(browser_));
+      CanCreateApplicationShortcuts(browser_)
+          && !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(
       IDC_CREATE_HOSTED_APP,
-      CanCreateApplicationShortcuts(browser_));
+      CanCreateApplicationShortcuts(browser_)
+          && !browser_->is_chromeless_mode());
 #endif
 
   command_updater_.UpdateCommandEnabled(
@@ -1176,24 +1197,38 @@ void BrowserCommandController::UpdateCom
 }
 
 void BrowserCommandController::UpdateCommandsForBookmarkEditing() {
+  bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+        || browser_->is_chromeless_mode();
+
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARK_PAGE,
-                                        CanBookmarkCurrentPage(browser_));
+                                        CanBookmarkCurrentPage(browser_)
+                                            && !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARK_ALL_TABS,
-                                        CanBookmarkAllTabs(browser_));
+                                        CanBookmarkAllTabs(browser_)
+                                            && !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_PIN_TO_START_SCREEN,
-                                        true);
+                                        !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForBookmarkBar() {
+  const bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
   command_updater_.UpdateCommandEnabled(IDC_SHOW_BOOKMARK_BAR,
       browser_defaults::bookmarks_enabled &&
       !profile()->GetPrefs()->IsManagedPreference(prefs::kShowBookmarkBar) &&
-      IsShowingMainUI());
+      IsShowingMainUI() && !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForFileSelectionDialogs() {
+  const bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
   UpdateSaveAsState();
-  UpdateOpenFileState(&command_updater_);
+  UpdateOpenFileState(&command_updater_, started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForFullscreenMode() {
@@ -1316,13 +1351,14 @@ void BrowserCommandController::UpdateSho
 
 // static
 void BrowserCommandController::UpdateOpenFileState(
-    CommandUpdater* command_updater) {
+      CommandUpdater* command_updater, bool started_in_chromeless) {
   bool enabled = true;
   PrefService* local_state = g_browser_process->local_state();
   if (local_state)
     enabled = local_state->GetBoolean(prefs::kAllowFileSelectionDialogs);
 
-  command_updater->UpdateCommandEnabled(IDC_OPEN_FILE, enabled);
+  command_updater->UpdateCommandEnabled(IDC_OPEN_FILE,
+                                        enabled && !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateReloadStopState(bool is_loading,
--- a/chrome/browser/ui/browser_command_controller.h
+++ b/chrome/browser/ui/browser_command_controller.h
@@ -68,13 +68,15 @@ class BrowserCommandController : public
   // outside code.
 
   // Updates the open-file state.
-  static void UpdateOpenFileState(CommandUpdater* command_updater);
+  static void UpdateOpenFileState(CommandUpdater* command_updater,
+                                  bool started_in_chromeless);
 
   // Update commands whose state depends on incognito mode availability and that
   // only depend on the profile.
   static void UpdateSharedCommandsForIncognitoAvailability(
       CommandUpdater* command_updater,
-      Profile* profile);
+      Profile* profile,
+      bool started_in_chromeless);
 
  private:
   class InterstitialObserver;
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -557,6 +557,9 @@ void CloseWindow(Browser* browser) {
 }
 
 void NewTab(Browser* browser) {
+  if (browser && browser->is_chromeless_mode())
+    return;
+
   content::RecordAction(UserMetricsAction("NewTab"));
   // TODO(asvitkine): This is invoked programmatically from several places.
   // Audit the code and change it so that the histogram only gets collected for
@@ -590,7 +593,7 @@ void RestoreTab(Browser* browser) {
   content::RecordAction(UserMetricsAction("RestoreTab"));
   TabRestoreService* service =
       TabRestoreServiceFactory::GetForProfile(browser->profile());
-  if (service)
+  if (service && !browser->is_chromeless_mode())
     service->RestoreMostRecentEntry(browser->tab_restore_service_delegate(),
                                     browser->host_desktop_type());
 }
--- a/chrome/browser/ui/browser_finder.cc
+++ b/chrome/browser/ui/browser_finder.cc
@@ -24,6 +24,7 @@ const int kMatchAny
 const int kMatchOriginalProfile         = 1 << 0;
 const int kMatchCanSupportWindowFeature = 1 << 1;
 const int kMatchTabbed                  = 1 << 2;
+const int kMatchNonChromeless           = 1 << 3;
 
 // Returns true if the specified |browser| matches the specified arguments.
 // |match_types| is a bitmask dictating what parameters to match:
@@ -51,7 +52,11 @@ bool BrowserMatches(Browser* browser,
   }
 
   if (match_types & kMatchTabbed)
-    return browser->is_type_tabbed();
+    return browser->is_type_tabbed() &&
+      !browser->is_chromeless_mode();
+
+  if (match_types & kMatchNonChromeless)
+    return !browser->is_chromeless_mode();
 
   return true;
 }
@@ -79,7 +84,7 @@ Browser* FindBrowserWithTabbedOrAnyType(
   BrowserList* browser_list_impl = BrowserList::GetInstance(desktop_type);
   if (!browser_list_impl)
     return NULL;
-  uint32 match_types = kMatchAny;
+  uint32 match_types = kMatchNonChromeless;
   if (match_tabbed)
     match_types |= kMatchTabbed;
   if (match_original_profiles)
--- a/chrome/browser/ui/gtk/browser_window_gtk.cc
+++ b/chrome/browser/ui/gtk/browser_window_gtk.cc
@@ -304,6 +304,13 @@ void BrowserWindowGtk::Init() {
     gtk_window_util::SetWindowCustomClass(window_,
         std::string(gdk_get_program_class()) + " (" + user_data_dir + ")");
   }
+  else if (browser_->is_chromeless_mode()) {
+    // The web application's url associated with the chromeless launch
+    // is appended for later reference.
+    // TODO: very so-so, find a better approach.
+    gtk_window_util::SetWindowCustomClass(window_,
+        web_app::GetWMClassFromAppName("chromeless"));
+  }
 
   // For popups, we initialize widgets then set the window geometry, because
   // popups need the widgets inited before they can set the window size
@@ -973,7 +980,7 @@ LocationBar* BrowserWindowGtk::GetLocati
 }
 
 void BrowserWindowGtk::SetFocusToLocationBar(bool select_all) {
-  if (!IsFullscreen())
+  if (!IsFullscreen() && IsToolbarSupported())
     GetLocationBar()->FocusLocation(select_all);
 }
 
@@ -1299,6 +1306,20 @@ void BrowserWindowGtk::Observe(int type,
   gtk_util::SetWindowIcon(window_, browser_->profile());
 }
 
+void BrowserWindowGtk::HandleTabCountChange(bool is_deleting) {
+  if (browser_ == NULL || browser_->tab_strip_model() == NULL)
+    return;
+
+  int count = browser_->tab_strip_model()->count();
+  const int HIDE_TAB_COUNT = is_deleting ? 2 : 1;
+  if (count == HIDE_TAB_COUNT) {
+    tabstrip_->Hide();
+  }
+  else {
+    tabstrip_->Show();
+  }
+}
+
 void BrowserWindowGtk::TabDetachedAt(WebContents* contents, int index) {
   // We use index here rather than comparing |contents| because by this time
   // the model has already removed |contents| from its list, so
@@ -1309,6 +1330,23 @@ void BrowserWindowGtk::TabDetachedAt(Web
     UpdateDevToolsForContents(NULL);
   }
   contents_container_->DetachTab(contents);
+
+  if (browser_->is_chromeless_mode())
+    HandleTabCountChange(false);
+}
+
+void BrowserWindowGtk::TabInsertedAt(content::WebContents* contents,
+                                     int index,
+                                     bool foreground) {
+  if (browser_->is_chromeless_mode())
+    HandleTabCountChange(false);
+}
+
+void BrowserWindowGtk::TabClosingAt(TabStripModel* tab_strip_model,
+                                    content::WebContents* contents,
+                                    int index) {
+  if (browser_->is_chromeless_mode())
+    HandleTabCountChange(true);
 }
 
 void BrowserWindowGtk::ActiveWindowChanged(GdkWindow* active_window) {
@@ -2202,8 +2240,12 @@ gboolean BrowserWindowGtk::OnFocusOut(Gt
 }
 
 void BrowserWindowGtk::ShowSupportedWindowFeatures() {
-  if (IsTabStripSupported())
-    tabstrip_->Show();
+  if (IsTabStripSupported()) {
+    if (browser_->is_chromeless_mode())
+      HandleTabCountChange(false);
+    else
+      tabstrip_->Show();
+  }
 
   if (IsToolbarSupported()) {
     toolbar_->Show();
@@ -2216,8 +2258,12 @@ void BrowserWindowGtk::ShowSupportedWind
 }
 
 void BrowserWindowGtk::HideUnsupportedWindowFeatures() {
-  if (!IsTabStripSupported())
-    tabstrip_->Hide();
+  if (!IsTabStripSupported()) {
+    if (browser_->is_chromeless_mode())
+      HandleTabCountChange(false);
+    else
+      tabstrip_->Hide();
+  }
 
   if (!IsToolbarSupported())
     toolbar_->Hide();
@@ -2257,7 +2303,8 @@ bool BrowserWindowGtk::GetWindowEdge(int
 
 bool BrowserWindowGtk::UseCustomFrame() const {
   // We don't use the custom frame for app mode windows or app window popups.
-  return use_custom_frame_pref_.GetValue() && !browser_->is_app();
+  return use_custom_frame_pref_.GetValue() &&
+      !browser_->is_app() && !browser_->is_chromeless_mode();
 }
 
 void BrowserWindowGtk::PlaceBookmarkBar(bool is_floating) {
--- a/chrome/browser/ui/gtk/browser_window_gtk.h
+++ b/chrome/browser/ui/gtk/browser_window_gtk.h
@@ -203,6 +203,13 @@ class BrowserWindowGtk
   virtual void TabDetachedAt(content::WebContents* contents,
                              int index) OVERRIDE;
 
+  virtual void TabInsertedAt(content::WebContents* contents,
+                             int index,
+                             bool foreground) OVERRIDE;
+  virtual void TabClosingAt(TabStripModel* tab_strip_model,
+                            content::WebContents* contents,
+                            int index) OVERRIDE;
+
   // Overridden from ActiveWindowWatcherXObserver.
   virtual void ActiveWindowChanged(GdkWindow* active_window) OVERRIDE;
 
@@ -346,6 +353,9 @@ class BrowserWindowGtk
   // ctrl-l, etc.).
   void ConnectAccelerators();
 
+  // 
+  void HandleTabCountChange(bool is_deleting);
+
   // Whether we should draw the tab background instead of the theme_frame
   // background because this window is a popup.
   bool UsingCustomPopupFrame() const;
--- a/chrome/browser/ui/gtk/global_menu_bar.cc
+++ b/chrome/browser/ui/gtk/global_menu_bar.cc
@@ -25,35 +25,43 @@
 #include "ui/base/accelerators/platform_accelerator_gtk.h"
 #include "ui/base/l10n/l10n_util.h"
 
+typedef bool (*GlobalMenuBarVisibilityHandler) (Browser * browser);
+
 struct GlobalMenuBarCommand {
   int str_id;
   int command;
   int tag;
+  GlobalMenuBarVisibilityHandler visibility_handler;
 };
 
 namespace {
 
+bool GlobalMenuBarVisibilityHandler_NotInChromelessMode(
+    Browser * browser) {
+  return browser && !browser->is_chromeless_mode();
+}
+
 const int MENU_SEPARATOR =-1;
 const int MENU_END = -2;
 const int MENU_DISABLED_LABEL = -3;
 
 GlobalMenuBarCommand file_menu[] = {
-  { IDS_NEW_TAB, IDC_NEW_TAB },
-  { IDS_NEW_WINDOW, IDC_NEW_WINDOW },
-  { IDS_NEW_INCOGNITO_WINDOW, IDC_NEW_INCOGNITO_WINDOW },
-  { IDS_REOPEN_CLOSED_TABS_LINUX, IDC_RESTORE_TAB },
-  { IDS_OPEN_FILE_LINUX, IDC_OPEN_FILE },
-  { IDS_OPEN_LOCATION_LINUX, IDC_FOCUS_LOCATION },
+  { IDS_NEW_TAB, IDC_NEW_TAB, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_NEW_WINDOW, IDC_NEW_WINDOW, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_NEW_INCOGNITO_WINDOW, IDC_NEW_INCOGNITO_WINDOW, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_REOPEN_CLOSED_TABS_LINUX, IDC_RESTORE_TAB, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_OPEN_FILE_LINUX, IDC_OPEN_FILE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_OPEN_LOCATION_LINUX, IDC_FOCUS_LOCATION, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_CREATE_SHORTCUTS, IDC_CREATE_SHORTCUTS },
+  { IDS_CREATE_SHORTCUTS, IDC_CREATE_SHORTCUTS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_CLOSE_WINDOW_LINUX, IDC_CLOSE_WINDOW },
   { IDS_CLOSE_TAB_LINUX, IDC_CLOSE_TAB },
-  { IDS_SAVE_PAGE, IDC_SAVE_PAGE },
+  { IDS_SAVE_PAGE, IDC_SAVE_PAGE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_SEPARATOR, MENU_SEPARATOR },
 
@@ -71,17 +79,17 @@ GlobalMenuBarCommand edit_menu[] = {
 
   { IDS_FIND, IDC_FIND },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_PREFERENCES, IDC_OPTIONS },
+  { IDS_PREFERENCES, IDC_OPTIONS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand view_menu[] = {
-  { IDS_SHOW_BOOKMARK_BAR, IDC_SHOW_BOOKMARK_BAR },
+  { IDS_SHOW_BOOKMARK_BAR, IDC_SHOW_BOOKMARK_BAR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_STOP_MENU_LINUX, IDC_STOP },
   { IDS_RELOAD_MENU_LINUX, IDC_RELOAD },
@@ -97,50 +105,50 @@ GlobalMenuBarCommand view_menu[] = {
 };
 
 GlobalMenuBarCommand history_menu[] = {
-  { IDS_HISTORY_HOME_LINUX, IDC_HOME },
-  { IDS_HISTORY_BACK_LINUX, IDC_BACK },
-  { IDS_HISTORY_FORWARD_LINUX, IDC_FORWARD },
+  { IDS_HISTORY_HOME_LINUX, IDC_HOME, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_HISTORY_BACK_LINUX, IDC_BACK, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_HISTORY_FORWARD_LINUX, IDC_FORWARD, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_HISTORY_VISITED_LINUX, MENU_DISABLED_LABEL,
-    GlobalMenuBar::TAG_MOST_VISITED_HEADER },
+    GlobalMenuBar::TAG_MOST_VISITED_HEADER, GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_HISTORY_CLOSED_LINUX, MENU_DISABLED_LABEL,
-    GlobalMenuBar::TAG_RECENTLY_CLOSED_HEADER },
+    GlobalMenuBar::TAG_RECENTLY_CLOSED_HEADER, GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_SHOWFULLHISTORY_LINK, IDC_SHOW_HISTORY },
+  { IDS_SHOWFULLHISTORY_LINK, IDC_SHOW_HISTORY, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand tools_menu[] = {
-  { IDS_SHOW_DOWNLOADS, IDC_SHOW_DOWNLOADS },
-  { IDS_SHOW_HISTORY, IDC_SHOW_HISTORY },
-  { IDS_SHOW_EXTENSIONS, IDC_MANAGE_EXTENSIONS },
+  { IDS_SHOW_DOWNLOADS, IDC_SHOW_DOWNLOADS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_SHOW_HISTORY, IDC_SHOW_HISTORY, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_SHOW_EXTENSIONS, IDC_MANAGE_EXTENSIONS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_TASK_MANAGER, IDC_TASK_MANAGER },
-  { IDS_CLEAR_BROWSING_DATA, IDC_CLEAR_BROWSING_DATA },
+  { IDS_TASK_MANAGER, IDC_TASK_MANAGER, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_CLEAR_BROWSING_DATA, IDC_CLEAR_BROWSING_DATA, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_VIEW_SOURCE, IDC_VIEW_SOURCE },
-  { IDS_DEV_TOOLS, IDC_DEV_TOOLS },
-  { IDS_DEV_TOOLS_CONSOLE, IDC_DEV_TOOLS_CONSOLE },
-  { IDS_DEV_TOOLS_DEVICES, IDC_DEV_TOOLS_DEVICES },
+  { IDS_VIEW_SOURCE, IDC_VIEW_SOURCE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_DEV_TOOLS, IDC_DEV_TOOLS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_DEV_TOOLS_CONSOLE, IDC_DEV_TOOLS_CONSOLE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_DEV_TOOLS_DEVICES, IDC_DEV_TOOLS_DEVICES, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand help_menu[] = {
 #if defined(GOOGLE_CHROME_BUILD)
-  { IDS_FEEDBACK, IDC_FEEDBACK },
+  { IDS_FEEDBACK, IDC_FEEDBACK, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 #endif
   { IDS_HELP_PAGE , IDC_HELP_PAGE_VIA_MENU },
   { MENU_END, MENU_END }
@@ -195,11 +203,12 @@ GlobalMenuBar::GlobalMenuBar(Browser* br
   }
 
   pref_change_registrar_.Init(browser_->profile()->GetPrefs());
-  pref_change_registrar_.Add(
-      prefs::kShowBookmarkBar,
-      base::Bind(&GlobalMenuBar::OnBookmarkBarVisibilityChanged,
-                 base::Unretained(this)));
-  OnBookmarkBarVisibilityChanged();
+  if (! browser_->is_chromeless_mode()) {
+    pref_change_registrar_.Add(
+        prefs::kShowBookmarkBar,
+        base::Bind(&GlobalMenuBar::OnBookmarkBarVisibilityChanged,
+                   base::Unretained(this)));
+ }
 }
 
 GlobalMenuBar::~GlobalMenuBar() {
@@ -224,8 +233,22 @@ void GlobalMenuBar::BuildGtkMenuFrom(
     std::map<int, GtkWidget*>* id_to_menu_item,
     GlobalMenuBarCommand* commands,
     GlobalMenuOwner* owner) {
+  // first pass to count the number of "visible" items
+  size_t count = 0;
+  for (int i = 0; commands[i].str_id != MENU_END; ++i) {
+    if (!commands[i].visibility_handler || commands[i].visibility_handler(browser_)) {
+      count++;
+    }
+  }
+  if (0 == count) {
+    return;
+  }
+
   GtkWidget* menu = gtk_menu_new();
   for (int i = 0; commands[i].str_id != MENU_END; ++i) {
+    if (commands[i].visibility_handler && !commands[i].visibility_handler(browser_)) {
+      continue;
+    }
     GtkWidget* menu_item = BuildMenuItem(
         commands[i].str_id, commands[i].command, commands[i].tag,
         id_to_menu_item, menu);
--- a/chrome/browser/ui/gtk/tabs/tab_strip_gtk.cc
+++ b/chrome/browser/ui/gtk/tabs/tab_strip_gtk.cc
@@ -784,9 +784,12 @@ void TabStripGtk::Init() {
   g_signal_connect(tabstrip_.get(), "drag-data-received",
                    G_CALLBACK(OnDragDataReceivedThunk), this);
 
-  newtab_button_.reset(MakeNewTabButton());
-  newtab_surface_bounds_.SetRect(0, 0, newtab_button_->SurfaceWidth(),
-                                 newtab_button_->SurfaceHeight());
+  if (window_ && window_->browser() &&
+          ! window_->browser()->is_chromeless_mode()) {
+    newtab_button_.reset(MakeNewTabButton());
+    newtab_surface_bounds_.SetRect(0, 0, newtab_button_->SurfaceWidth(),
+                                   newtab_button_->SurfaceHeight());
+  }
 
   gtk_widget_show_all(tabstrip_.get());
 
@@ -1455,6 +1458,9 @@ void TabStripGtk::GenerateIdealBounds()
 
 void TabStripGtk::LayoutNewTabButton(double last_tab_right,
                                      double unselected_width) {
+  if (window_ && window_->browser() && window_->browser()->is_chromeless_mode())
+    return;
+
   GtkWidget* toplevel = gtk_widget_get_ancestor(widget(), GTK_TYPE_WINDOW);
   bool is_maximized = false;
   if (toplevel) {
@@ -1508,8 +1514,10 @@ void TabStripGtk::GetDesiredTabWidths(in
   int available_width = tabstrip_allocation.width;
   if (available_width_for_tabs_ < 0) {
     available_width = bounds_.width();
-    available_width -=
+    if (newtab_button_.get() != NULL) {
+      available_width -=
         (kNewTabButtonHOffset + newtab_button_->WidgetAllocation().width);
+    }
   } else {
     // Interesting corner case: if |available_width_for_tabs_| > the result
     // of the calculation in the conditional arm above, the strip is in
@@ -2067,8 +2075,11 @@ gboolean TabStripGtk::OnExpose(GtkWidget
   gdk_region_union_with_rect(event->region, &event->area);
 
   // Paint the New Tab button.
-  gtk_container_propagate_expose(GTK_CONTAINER(tabstrip_.get()),
-      newtab_button_->widget(), event);
+  if (newtab_button_.get() != NULL) {
+    // Paint the New Tab button.
+    gtk_container_propagate_expose(GTK_CONTAINER(tabstrip_.get()),
+        newtab_button_->widget(), event);
+  }
 
   // Paint the tabs in reverse order, so they stack to the left.
   TabGtk* selected_tab = NULL;
@@ -2265,6 +2276,9 @@ CustomDrawButton* TabStripGtk::MakeNewTa
 }
 
 void TabStripGtk::SetNewTabButtonBackground() {
+  if (newtab_button_.get() == NULL) {
+    return;
+  }
   SkColor color = theme_service_->GetColor(
       ThemeProperties::COLOR_BUTTON_BACKGROUND);
   SkBitmap background = theme_service_->GetImageNamed(
--- a/chrome/browser/ui/startup/startup_browser_creator_impl.cc
+++ b/chrome/browser/ui/startup/startup_browser_creator_impl.cc
@@ -385,6 +385,12 @@ bool StartupBrowserCreatorImpl::Launch(P
   } else {
     RecordLaunchModeHistogram(urls_to_open.empty() ?
                               LM_TO_BE_DECIDED : LM_WITH_URLS);
+    
+    if (IsChromelessLaunch(NULL)) {
+      // Open user-specified URLs like pinned tabs and startup tabs.
+      if (ProcessSpecifiedURLs(urls_to_open, desktop_type))
+	return true;
+    }
 
     ProcessLaunchURLs(process_startup, urls_to_open, desktop_type);
 
@@ -409,6 +415,16 @@ bool StartupBrowserCreatorImpl::Launch(P
   return true;
 }
 
+bool StartupBrowserCreatorImpl::IsChromelessLaunch(std::string* url)
+{
+  if (command_line_.HasSwitch(switches::kChromeless)) {
+    if (url)
+      *url = command_line_.GetSwitchValueASCII(switches::kChromeless);
+    return true;
+  }
+  return false;
+}
+
 bool StartupBrowserCreatorImpl::IsAppLaunch(std::string* app_url,
                                             std::string* app_id) {
   if (command_line_.HasSwitch(switches::kApp)) {
@@ -695,7 +711,8 @@ Browser* StartupBrowserCreatorImpl::Proc
   // mode. Also, no pages should be opened automatically if the session
   // crashed. Otherwise it might trigger another crash, locking the user out of
   // chrome. The crash infobar is shown in this case.
-  if (!IncognitoModePrefs::ShouldLaunchIncognito(command_line_,
+  if (!IsChromelessLaunch(NULL) &&
+      !IncognitoModePrefs::ShouldLaunchIncognito(command_line_,
                                                  profile_->GetPrefs()) &&
       !HasPendingUncleanExit(profile_)) {
     tabs = PinnedTabCodec::ReadPinnedTabs(profile_);
@@ -774,6 +791,10 @@ Browser* StartupBrowserCreatorImpl::Open
   if (!profile_ && browser)
     profile_ = browser->profile();
 
+  if (IsChromelessLaunch(NULL)) {
+    browser = new Browser(Browser::CreateParams::CreateChromeless(profile_, chrome::HOST_DESKTOP_TYPE_NATIVE));
+  }
+
   if (!browser || !browser->is_type_tabbed()) {
     browser = new Browser(Browser::CreateParams(profile_, desktop_type));
   } else {
@@ -850,6 +871,11 @@ void StartupBrowserCreatorImpl::AddInfoB
   if (!browser || !profile_ || browser->tab_strip_model()->count() == 0)
     return;
 
+  // We consider that being in a chromeless launch, we are to minimize
+  // as much as possible the most obvious "classic" Chromium behavior.
+  if (IsChromelessLaunch(NULL))
+      return;
+
   if (HasPendingUncleanExit(browser->profile()))
     SessionCrashedInfoBarDelegate::Create(browser);
 
--- a/chrome/browser/ui/startup/startup_browser_creator_impl.h
+++ b/chrome/browser/ui/startup/startup_browser_creator_impl.h
@@ -83,6 +83,7 @@ class StartupBrowserCreatorImpl {
   // e.g. --app=http://www.google.com/ or --app_id=... return true.
   // In this case |app_url| or |app_id| are populated if they're non-null.
   bool IsAppLaunch(std::string* app_url, std::string* app_id);
+  bool IsChromelessLaunch(std::string* url);
 
   // If IsAppLaunch is true, tries to open an application window.
   // If the app is specified to start in a tab, or IsAppLaunch is false,
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -159,6 +159,9 @@ const char kCheckForUpdateIntervalSec[]
 const char kCheckCloudPrintConnectorPolicy[] =
     "check-cloud-print-connector-policy";
 
+// Specifies a given URL to be opened in a chromeless mode.
+const char kChromeless[]                    = "chromeless";
+
 // Comma-separated list of SSL cipher suites to disable.
 const char kCipherSuiteBlacklist[]          = "cipher-suite-blacklist";
 
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -57,6 +57,7 @@ extern const char kAutomationClientChann
 extern const char kCertificateTransparencyLog[];
 extern const char kCheckForUpdateIntervalSec[];
 extern const char kCheckCloudPrintConnectorPolicy[];
+extern const char kChromeless[];
 extern const char kCipherSuiteBlacklist[];
 extern const char kCloudPrintFile[];
 extern const char kCloudPrintJobTitle[];
--- a/chrome/common/extensions/api/extension.json
+++ b/chrome/common/extensions/api/extension.json
@@ -138,6 +138,33 @@
         }
       },
       {
+        "name": "isChromelessWindow",
+        "nocompile": true,
+        "nodoc": true,
+        "type": "function",
+        "description": "Checks is a given extension runs part of a chromeless window.",
+        "parameters": [
+          {
+            "type": "integer",
+            "name": "tabId",
+            "optional": true,
+            "description": "The tab id corresponding to the window to restrict the request to."
+          }
+          ,
+          {
+            "type": "function",
+            "name": "callback",
+            "parameters": [
+              {
+                "name": "isChromelessWindow",
+                "type": "boolean",
+                "description": "True if the extension runs part of a chromeless window, false otherwise."
+              }
+            ]
+          }
+        ]
+      },
+      {
         "name": "isAllowedIncognitoAccess",
         "type": "function",
         "description": "Retrieves the state of the extension's access to Incognito-mode (as determined by the user-controlled 'Allowed in Incognito' checkbox.",
